---
title: 【数据结构-2】树
toc: true
tags: 数据结构
category: 计算机通识
thumbnail: /images/thumbnails/ds2.jpeg
date: 2019-07-02 17:02:38
---

# 树

[TOC]

> 考纲内容：
>
> 1. 树的基本概念和术语
> 2. 树的遍历
> 3. 二叉树及其性质
> 4. 普通树和二叉树的转换
> 5. 树的存储结构，标准形式
> 6. 完全树的数组形式存储
> 7. 树的应用
> 8. Huffman树的定义与应用



### 树的基本概念

#### 定义

树是n个结点的有限集合，n = 0 时称为<b>空树</b>，这是一种特殊情况。任意一棵非空树中应满足：

1. 有且仅有一个根结点
2. 当 n > 1 时，其余结点可分为m (m > 0)个互不相交的有限集合 T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>…, T<sub>m</sub>，其中每个集合本身又是一棵树，称为根结点的子树。

> 显然，树的定义是递归的，是一种递归的数据结构。

树作为一种逻辑结构，同时也是一种分层结构，具有以下特点：

1. 树的根结点没有前驱结点，除根结点以外的结点有且只有一个前驱结点。
2. 树中所有结点可以有零个或多个后继结点。

> 树适合表示具有层次结构的数据，树中某个结点最多只和上层一个结点有直接关系，根结点没有直接上层结点，因此<b>在n个结点的树中有 n - 1 条边。</b>

#### 基本术语

1. 祖先结点，子孙结点，兄弟结点，父结点

2. <b>度</b>：某个结点的子结点个数称为该结点的<b>度</b>

3. 分支结点：度大于0的结点

4. <b> 深度</b>、<b>高度</b>、<b>层次</b>

   > 结点的层次从树根开始定义，根结点为第一层(有的资料定义为第0层)，它的子结点为第二层，以此类推。
   >
   > 结点的<b>深度</b>：从根结点开始自顶向下逐层累加
   >
   > 结点的<b>高度</b>: 从叶子结点开始自底向上逐层累加。
   >
   >  树的度：树中所有结点的度数的最大值
   >
   > 树的高度(又称深度)：是树中结点的最大层数。

5. 有序树和无序树：树种结点的子树从左到右是有次序的，不能交换。
6. 路径和路径长度：树种两个结点之间的路径是由这两个结点之间经过的结点序列构成的，而路径长度是路径上所经过的边的个数。
7. 森林

### 树的性质

1. 树中的结点数等于所有结点的<b>度</b>数加1。
2. 度为 m 的树中第i层上至多有m<sup>i-1</sup>个结点(i >= 1)。
3. 高度为 h 的 m 叉树至多有(m<sup>k</sup> - 1)/(m - 1)个结点。
4. 具有 n 个结点的 m 叉树的最小高度为[ log<sub>m</sub>(n(m - 1) + 1) ]（向上取整）。

> 已知一棵度为 m 的树中，有n1个度为1的结点，有 n2 个度为 2 的结点...
>
> 1. 总结点数 = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub> + … n<sub>m</sub>
> 2. 总分支数 = 1n<sub>1</sub> + 2n<sub>2</sub> + … mn<sub>m</sub>
> 3. 总结点数 = 总分支数 + 1

### 二叉树

#### 定义和性质

一个结点至多有两棵子树，即二叉树中不存在度大于 2 的结点，并且子树有左右之分，不能任意颠倒。

> 二叉树和度为 2 的有序树的区别：
>
> 1. 度为 2 的树至少有3个结点，二叉树可以为空。
> 2. 二叉树无论其子结点数是否为2都需要确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的。

#### 特殊的二叉树

- 满二叉树： 高度为 h, 结点数 2 <sup>h </sup> - 1

- 完全二叉树：和满二叉树中的结点序号一一对应
- 二叉排序树：左子树上的所有关键字均小于右结点上的关键字，左子树和右子树又各自是一棵二叉排序树。
- 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1.

> 若有n个结点的<b>完全二叉树</b>按如下规则从左到右编号，根结点 1， 第一层 2， 3， 第二层 4， 5， 6 以此类推（层次序编号）
>
> 完全二叉树的特点：
>
> 1. 若 i < (n / 2) 则，结点 i 为分支结点，否则为子结点。
> 2. 叶子结点只可能在层次最大的两层上出现，最大层次中的叶子结点都依次排列在该层最左侧位置
> 3. <b>若有度为 1 的结点，则只可能有一个，且该结点只有左孩子没有右孩子。</b>
> 4. 按层次序编号后，一旦出现某结点（编号为 i ）为叶子结点或只有左孩子，则编号大于 i 的结点均为叶子结点
> 5. 若  n 为 奇数，则每个分支结点都有左孩子和右孩子，若n 为偶数，则编号最大的分支结点只有左孩子，没有右孩子。
> 6. 当 i > 1时，结点的双亲结点的编号为[i / 2]，即当i 为偶数时，双亲结点编号为 i / 2 , 结点为左孩子；当 i 为奇数时，双亲结点编号为 (i - 1) / 2 , 结点为右孩子。
> 7. 当 2i <= n 时，结点的左孩子编号为 2i ，否则无左孩子。
> 8. 当 2i + 1 <= n 时，结点 i 的右孩子编号为 2i + 1，否则无右孩子。
> 9.  结点所在层次（深度）为 [log<sub>2</sub>i] + 1。
> 10. 具有 n 个结点的完全二叉树的高度为  [log<sub>2</sub>(n + 1)] 或   [log<sub>2</sub>(n)] + 1



#### 二叉树的性质

- 非空二叉树上的叶子结点数等于度为 2 的结点数加 1，即 n0 = n2 + 1。

![image-20190706222555555](/images/mse/image-20190706222555555.png)

- 非空二叉树上第  k 层上至多有 2<sup>k - 1</sup> 个结点。

- 高度为 h 的二叉树至多有  2<sup>h</sup> - 1 个结点。

![image-20190706222513006](/images/mse/image-20190706222513006.png)



![image-20190706222441932](/images/mse/image-20190706222441932.png)

#### 存储结构

顺序存储结构

> 完全二叉树和满二叉树采用顺序存储比较合适，结点的序号可以唯一地反应结点之间的逻辑关系。
>
> 这种存储结构要从数组下标1开始存储树中的结点

链式存储结构

> 由于顺序存储空间利用率较低，因此二叉树一般都采用链式存储结构。即用一个链表来存储一棵二叉树，二叉树中的每一个结点用链表的一个链结点来存储。二叉链表至少包含3个域：数据域 data，左指针lchild，右指针rchild。

```c++
typeof struct BiTNode {
  ElemType data;
  struct BitNode *lchild, *rchild;
}BiTNode, *BiTree
```

> 容易验证，在含有 n 个结点的二叉链表中，含有 n + 1 个空链域。



### 二叉树的遍历

![image-20190706222335281](/images/mse/image-20190706222335281.png)

常见的遍历次序： 

- 先序遍历（NLR）
- 中序遍历（LNR）
- 后序遍历（LRN）

> “序”指根结点，即根结点何时被访问。

#### 先序遍历

1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树

![image-20190706222129782](/images/mse/image-20190706222129782.png)

```c++
void PreOrder(BiTree T) {
  if (T != NULL) {
    visit(T);
    PreOrder(T->lchild);
    preOrder(T->rchild);
  }
}
```

#### 中序遍历

1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

![image-20190706222010915](/images/mse/image-20190706222010915.png)

```c++
void InOrder(BiTree T) {
  if (T != NULL) {
    InOrder(T->lchild);
    visit(T);
    InOrder(T->rchild);
  }
}
```

#### 后序遍历

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

![image-20190706222159892](/images/mse/image-20190706222159892.png)

```c++
void PostOrder(BiTree T) {
  if (T != null) {
    PostOrder(T->lchild);
    PostOrder(T->rchild);
    visit(T);
  }
}
```

> 三种遍历方式时间复杂度都是 O(n)

#### 非递归算法

借助栈，可以将二叉树的遍历算法转换为非递归算法。以中序遍历为例：

```c++
void InOrder2(BiTree T) {
  InStack(S); BiTree p = T;
  whild(p || !IsEmpty(S)) {
    if (p) {
      Push(S, p);
      p->p->lchild;
    }
    else {
      Pop(S, p);
      visit(p);
      p->p->rchild;
    }
  }
}
```

> 显然，非递归算法的效率要高于递归算法。

![image-20190706222743640](/images/mse/image-20190706222743640.png)

![image-20190706222758684](/images/mse/image-20190706222758684.png)

![image-20190706222817400](/images/mse/image-20190706222817400.png)

#### 层次遍历

即按照层次序号1，2，3，4的顺序进行结点的访问。要进行层次序遍历，需要借助一个队列。先将根结点入队，然后出队，访问该结点，如果他有左子树，则左子树根结点入队；若他有右子树，将右子树根结点入队。然后出队，访问出队结点，如此反复。

```c++
void LevelOrder(BiTree T) {
  InitQueue(Q);
  BiTree p;
  EnQueue(Q, T);
  whild (!isEmpty(Q)) {
    DeQueue(Q, p);
    visit (p);
    if (p->lchild != NULL) {
      EnQueue(Q, p->lchild);
    } 
    if (p->rchild != NULL) {
      EnQueue(Q, p->rchild);
    }
  }
}
```

![image-20190706222902773](/images/mse/image-20190706222902773.png)

### 线索二叉树

![image-20190706225652913](/images/mse/image-20190706225652913.png)

![image-20190706225904169](/images/mse/image-20190706225904169.png)

![image-20190706225921758](/images/mse/image-20190706225921758.png)



![image-20190706230033322](/images/mse/image-20190706230033322.png)
> 中序线索二叉树的遍历

![image-20190706230606123](/images/mse/image-20190706230606123.png)



### 树、森林

常用的三种存储结构：

- 双亲表示法（顺序存储结构）
  - 找到双亲结点的时间复杂度 O(1)

![image-20190706190620198](/images/mse/image-20190706190620198.png)

- 孩子表示法（链式存储）

每个结点的孩子结点排列起来存储成一个单链表，所以n个结点就有 n 个链表；如果是叶子结点，那这个结点的孩子单链表是空的。然后n个单链表的头指针又存储在一个顺序表（数组）中。

![image-20190706191411490](/images/mse/image-20190706191411490.png)

> 需要设计两种结点结构类型：一个是孩子链表的结点，二是每个孩子链表的表头结点（存在数组中）
>
> ```c
> typedef char ElemType;
> typedef struct CNode{
>   int child;
>   struct CNode *next;
> }CNode, *Child;
> 
> typedef struct{
>   ElemType data;
>   Child firstchild;
> }TNode;
> ```

- 孩子兄弟表示法（二叉树表示法）

设置两个指针，分别指向该结点的第一个孩子结点和该结点的兄弟结点。

![image-20190706191641377](/images/mse/image-20190706191641377.png)



如何将一棵树转化为二叉树？

![image-20190706234331183](/images/mse/image-20190706234331183.png)

![image-20190706234638233](/images/mse/image-20190706234638233.png)

![image-20190706234732815](/images/mse/image-20190706234732815.png)


![image-20190706234853159](/images/mse/image-20190706234853159.png)

#### 树的遍历

![image-20190706235054271](/images/mse/image-20190706235054271.png)

![image-20190706235111538](/images/mse/image-20190706235111538.png)

![image-20190706235129657](/images/mse/image-20190706235129657.png)

> 💡树的后续遍历序列 和对应二叉树的中序遍历序列是一致的

### 树的应用

#### 并查集

> 并查集是一种用来合并不相交集合的数据结构。一个比较常用的地方是：用来检测一个图里面是不是包含有环。这个结构在Kruskal算法（最小生成树）里面有非常重要的作用

```c
#define VERTICES 6;

void initialise(int parent[]) {
  int i;
  for ( i= 0; i < VERTICES; i++ ) {
    parent[i] = -1;
  }
}

int find_root(int x, int parent[]) {
  int x_root = x;
  while (parent[x_root]) != -1) {
    x_root = parent[x_root];
  }
  return x_root;
}

/* 1 - union successfully, 0 -failed */
int union_vertices(int x, int y, int parent[]) {
  int x_root = find_root(x, parent);
  int y_root find_root(y, parent);
  if (x_root == y_root) {
    return 0;
  }
  else {
    parent[x_root] = y_root;
    return 1;
  }
}

int main() {
  int parent[VERTICES] = {0};
  // 6条边，每条边两端有两个值
  int edges[6][2] = {
    {0, 1}, {1, 2}, {1, 3}, 
    {2, 4}, {3, 4}, {2, 5}
  };
  initialise(parent);
  int i;
  for (i = 0; i < 6; i++) {
    int x = edges[i][0];
    int y = edger[i][1];
    // 检测有没有环
    if (union_vertices(x, y, parent) == 0) {
      print("Cycle detected!\n");
      exit(0);
    }
    printf("No cycles detected.\n")
  }
  return 0;
}
```

> 上面例程的图形和结果：
>
> ![image-20190707113654720](/images/mse/image-20190707113654720.png)
>
> // Cycle detected!

#### 二叉排序树

> 在查找中讨论

#### 平衡二叉树（AVL树）

> 在查找中会具体讨论

平衡二叉树是特殊的二叉排序树，特殊的地方在于左右子树高度之差绝对值不超过1。

结点的平衡因子：该结点的左右子树的高度差。

![image-20190707114751302](/images/mse/image-20190707114751302.png)

> 在平衡二叉树中，所有结点的平衡因子只可能是 -1, 0 或 1；

![image-20190707115947652](/images/mse/image-20190707115947652.png)



#### 哈夫曼树

![image-20190706231044972](/images/mse/image-20190706231044972.png)

![image-20190706231130403](/images/mse/image-20190706231130403.png)

##### 术语

权： 树中结点相关的数值

路径长度：从树中某个结点到另一个结点之间的分支数目（经过的边数）

带权路径长度：从树的根结点到任意结点的路径长度（经过的边数）与该结点上的权值的乘积称为该结点的带权路径长度。

![image-20190706231254626](/images/mse/image-20190706231254626.png)

> 上图权值的实际意义：每个分数段人数的百分比。



<b>哈夫曼树</b>：含有N个带权叶子结点的二叉树中，其中带权路径长度(WPL)最小的二叉树，也称为最优二叉树。
![image-20190706232321537](/images/mse/image-20190706232321537.png)

![image-20190706232855031](/images/mse/image-20190706232855031.png)

性质：哈夫曼树没有度为1的结点



#### 哈夫曼编码

![image-20190706233301153](/images/mse/image-20190706233301153.png)

![image-20190706233328573](/images/mse/image-20190706233328573.png)

森林转化成树：
![image-20190706233342372](/images/mse/image-20190706233342372.png)
